
**i) What is the objective of refining the Use-Case model in object design?Why is it important?**

**English Answer**:
**Objective**: The objective of refining the use-case model in object design is to make the use cases more detailed and precise so they can guide the design of the system’s objects and interactions.

**Why It’s Important**:
- **Clarifies Requirements**: Refining use cases ensures that the system’s functionality is clearly defined, reducing confusion during design.
- **Guides Object Design**: Detailed use cases help identify the objects, their responsibilities, and how they interact, making it easier to create classes and methods.
- **Reduces Errors**: Clear use cases catch missing or incorrect requirements early, preventing costly changes later.
- **Improves Communication**: A refined model helps developers, designers, and stakeholders understand the system better, ensuring everyone is on the same page.
- **Supports Testing**: Detailed use cases provide a basis for creating test cases to check if the system works as expected.

For example, a use case like “User logs in” is refined to include steps like entering a username, validating credentials, and handling errors, which helps design the login system’s objects.

**Bangla Translation and Explanation**:
**প্রশ্ন**: অবজেক্ট ডিজাইনে ইউজ-কেস মডেল পরিমার্জনের উদ্দেশ্য কী? এটি কেন গুরুত্বপূর্ণ?  
**উত্তর**:  
**উদ্দেশ্য**: অবজেক্ট ডিজাইনে ইউজ-কেস মডেল পরিমার্জনের উদ্দেশ্য হলো ইউজ-কেসগুলোকে আরও বিস্তারিত ও সুনির্দিষ্ট করা যাতে এগুলো সিস্টেমের অবজেক্ট ও তাদের মিথস্ক্রিয়া ডিজাইনের জন্য গাইড করতে পারে। এতে উচ্চ-স্তরের ইউজ-কেসগুলোকে ছোট ধাপে ভাগ করা, ইনপুট, আউটপুট  সিস্টেমের অবজেক্ট (যেমন ক্লাস, অ্যাট্রিবিউট, মেথড) এর সাথে সামঞ্জস্য করা হয়।  

**কেন গুরুত্বপূর্ণ**:  
- **চাহিদা পরিষ্কার করে**: পরিমার্জিত ইউজ-কেস সিস্টেমের কার্যকারিতা স্পষ্ট করে, ডিজাইনে বিভ্রান্তি কমায়।  
- **অবজেক্ট ডিজাইন গাইড করে**: বিস্তারিত ইউজ-কেস অবজেক্ট, তাদের দায়িত্ব, এবং মিথস্ক্রিয়া চিহ্নিত করে, ক্লাস ও মেথড তৈরি সহজ করে।  
- **ভুল কমায়**: স্পষ্ট ই�ユজ-কেস ভুল বা মিসিং চাহিদা আগে ধরতে সাহায্য করে, পরে খরচ বাঁচায়।  
- **যোগাযোগ উন্নত করে**: পরিমার্জিত মডেল ডেভেলপার, ডিজাইনার, এবং স্টেকহোল্ডারদের সিস্টেম বুঝতে সাহায্য করে।  
- **টেস্টিং সহায়তা**: বিস্তারিত ইউজ-কেস টেস্ট কেস তৈরির ভিত্তি দেয় যাতে সিস্টেম ঠিকঠাক কাজ করে কিনা তা পরীক্ষা করা যায়।  

যেমন, “ব্যবহারকারী লগইন করে” ইউজ-কেসকে ইউজারনেম দেওয়া, শংসাপত্র যাচাই, এবং ত্রুটি সামলানোর ধাপে ভাগ করে লগইন সিস্টেমের অবজেক্ট ডিজাইন করা হয়।  

**ব্যাখ্যা**: ইউজ-কেস মডেল পরিমার্জন করা হয় যাতে সিস্টেমের কাজগুলো স্পষ্ট এবং বিস্তারিত হয়। এটি অবজেক্ট ডিজাইনের জন্য গাইড করে, ভুল কমায়, এবং সবাইকে একই পথে রাখে। এটা টেস্টিং এবং সঠিক সিস্টেম তৈরির জন্যও জরুরি।

---
`Question Number: 4`

**ii) Why do many new systems analysts fail to effectively analyze problems? What can they do to become more effective? Show the categories of resoures to be allocated to the project.**

**English Answer**:
**Why New Systems Analysts Fail**:
New systems analysts often struggle to analyze problems effectively because:
- **Lack of Experience**: They may not know how to ask the right questions or identify key issues due to limited practical experience.
- **Poor Communication**: They fail to communicate clearly with stakeholders, leading to misunderstandings about requirements.
- **Poor Problem-Solving Skills**: They struggle to break down complex problems into manageable parts or prioritize issues.
- **Time Pressure**: Rushing under tight deadlines can lead to superficial analysis instead of thorough investigation.

**What They Can Do to Improve**:
- **Ask Questions**: Engage stakeholders actively, ask open-ended questions, and clarify unclear requirements.
- **Use Structured Methods**: Apply techniques like interviews, surveys, or flowcharts to organize and analyze problems systematically.
- **Learn from Others**: Shadow experienced analysts or seek mentorship to gain practical insights.
- **Practice Active Listening**: Listen carefully to stakeholders to understand their needs and concerns fully.
- **Take Training**: Attend workshops or courses on systems analysis, problem-solving, and communication skills.

**Categories of Resources to Allocate**:
- **Human Resources**: Analysts, developers, testers, and other team members with the right skills.
- **Financial Resources**: Budget for salaries, tools, and other project expenses.
- **Technological Resources**: Software, hardware, and tools needed for analysis and development.
- **Time Resources**: Enough time allocated for each phase, like analysis, design, and testing.
- **Information Resources**: Data, documents, or stakeholder feedback to support analysis.

**Bangla Translation and Explanation**:
**প্রশ্ন**: কেন অনেক নতুন সিস্টেম বিশ্লেষক সমস্যা কার্যকরভাবে বিশ্লেষণ করতে ব্যর্থ হয়? তারা কী করতে পারে উন্নতির জন্য? প্রকল্পে বরাদ্দ করার সম্পদের ক্যাটাগরি দেখান।  
**উত্তর**:  
**কেন নতুন বিশ্লেষক ব্যর্থ হয়**:  
নতুন সিস্টেম বিশ্লেষকরা প্রায়ই সমস্যা বিশ্লেষণে ব্যর্থ হয় কারণ:  
- **অভিজ্ঞতার অভাব**: তারা সঠিক প্রশ্ন করতে বা মূল সমস্যা চিহ্নিত করতে জানে না কারণ তাদের বাস্তব অভিজ্ঞতা কম।  
- **দুর্বল যোগাযোগ**: স্টেকহোল্ডারদ ව্যবহারকারীর চাহিদা সম্পর্কে ভুল বোঝে।  
- **বিস্তারিত মিস করা**: তারা গুরুত্বপূর্ণ তথ্য মিস করে বা যাচাই না করে ধরে নেয়, ফলে বিশ্লেষণ অসম্পূর্ণ হয়।  
- **সমস্যা সমাধানের দক্ষতা কম**: জটিল সমস্যাকে ছোট অংশে ভাগ করতে বা অগ্রাধিকার দিতে তারা অসুবিধায় পড়ে।  
- **সময়ের চাপ**: কম সময়ের কারণে তারা গভীর বিশ্লেষণ না করে তাড়াহুড়ো করে।  

**উন্নতির জন্য কী করতে পারে**:  
- **প্রশ্ন করা**: স্টেকহোল্ডারদের সাথে সক্রিয়ভাবে কথা বলা, খোলা প্রশ্ন করা, এবং অস্পষ্ট চাহিদা পরিষ্কার করা।  
- **স্ট্রাকচার্ড পদ্ধতি ব্যবহার**: ইন্টারভিউ, সার্ভে, বা ফ্লোচার্ট ব্যবহার করে সমস্যা সংগঠিতভাবে বিশ্লেষণ করা।  
- **অন্যদের কাছ থেকে শেখা**: অভিজ্ঞ বিশ্লেষকদের সাথে কাজ করে বা মেন্টরের পরামর্শ নিয়ে বাস্তব জ্ঞান অর্জন।  
- **সক্রিয় শোনা**: স্টেকহোল্ডারদের কথা মনোযোগ দিয়ে শুনে তাদের চাহিদা পুরোপুরি বোঝা।  
- **প্রশিক্ষণ নেওয়া**: সিস্টেম বিশ্লেষণ, সমস্যা সমাধান, এবং যোগাযোগ দক্ষতার উপর ওয়ার্কশপ বা কোর্স করা।  

**বরাদ্দ করার সম্পদের ক্যাটাগরি**:  
- **মানব সম্পদ**: বিশ্লেষক, ডেভেলপার, টেস্টার, এবং সঠিক দক্ষতার অন্যান্য দলের সদস্য।  
- **আর্থিক সম্পদ**: বেতন, সরঞ্জাম, এবং প্রকল্পের অন্যান্য খরচের জন্য বাজেট।  
- **প্রযুক্তিগত সম্পদ**: বিশ্লেষণ ও ডেভেলপমেন্টের জন্য সফটওয়্যার, হার্ডওয়্যার, এবং সরঞ্জাম।  
- **সময় সম্পদ**: বিশ্লেষণ, ডিজাইন, এবং টেস্টিংয়ের জন্য পর্যাপ্ত সময় বরাদ্দ।  
- **তথ্য সম্পদ**: বিশ্লেষণের জন্য ডেটা, ডকুমেন্ট, বা স্টেকহোল্ডারদের মতামত।  

**ব্যাখ্যা**: নতুন বিশ্লেষকরা অভিজ্ঞতার অভাব, দুর্বল যোগাযোগ, বা সময়ের চাপে সমস্যা বিশ্লেষণে ব্যর্থ হয়। তারা প্রশ্ন করে, পদ্ধতি ব্যবহার করে, এবং প্রশিক্ষণ নিয়ে উন্নতি করতে পারে। প্রকল্পে লোক, টাকা, সরঞ্জাম, সময়, এবং তথ্য বরাদ্দ করতে হয় যাতে কাজ ভালোভাবে হয়।

---
**iii) Show the commonly used technique for prioritinzing system requirements.**

**English Answer**:
A commonly used technique for prioritizing system requirements is the **MoSCoW Method**. This method categorizes requirements based on their importance to ensure the most critical ones are addressed first. The categories are:
- **Must Have**: Essential requirements that the system cannot function without. For example, a login feature for a secure app.
- **Should Have**: Important requirements that add significant value but can be delayed if needed. For example, a password reset feature.
- **Could Have**: Desirable but non-essential requirements that can be included if time and budget allow. For example, a user profile customization option.
- **Won’t Have**: Requirements that are not needed for this version of the system but may be considered later. For example, a future integration with another app.

**How It Works**:
- Stakeholders and the project team review all requirements.
- Each requirement is placed in one of the MoSCoW categories based on its impact and urgency.
- The team focuses on “Must Have” and “Should Have” requirements first to deliver a functional system within constraints.

**Why It’s Effective**:
- It’s simple and easy to understand.
- It ensures critical features are prioritized, keeping the project on track.
- It helps manage stakeholder expectations by clarifying what will and won’t be included.

**Bangla Translation and Explanation**:
**প্রশ্ন**: সিস্টেম চাহিদা অগ্রাধিকার দেওয়ার জন্য সাধারণভাবে ব্যবহৃত টেকনিক দেখান।  
**উত্তর**:  
সিস্টেম চাহিদা অগ্রাধিকার দেওয়ার জন্য সাধারণ টেকনিক হলো **MoSCoW মেথড**। এটি চাহিদাগুলোকে তাদের গুরুত্ব অনুযায়ী ক্যাটাগরিতে ভাগ করে যাতে সবচেয়ে জরুরি চাহিদাগুলো আগে করা হয়। ক্যাটাগরিগুলো হলো:  
- **মাস্ট হ্যাভ (Must Have)**: অপরিহার্য চাহিদা যা ছাড়া সিস্টেম কাজ করবে না। যেমন, একটি সুরক্ষিত অ্যাপের জন্য লগইন ফিচার।  
- **শুড হ্যাভ (Should Have)**: গুরুত্বপূর্ণ চাহিদা যা মূল্য যোগ করে কিন্তু প্রয়োজনে পিছিয়ে দেওয়া যায়। যেমন, পাসওয়ার্ড রিসেট ফিচার।  
- **কুড হ্যাভ (Could Have)**: কাম্য কিন্তু অপরিহার্য নয় এমন চাহিদা, সময় ও বাজেট থাকলে করা যায়। যেমন, ব্যবহারকারীর প্রোফাইল কাস্টমাইজেশন।  
- **ওন্ট হ্যাভ (Won’t Have)**: এই সংস্করণে দরকার নেই কিন্তু ভবিষ্যতে বিবেচনা করা যেতে পারে। যেমন, অন্য অ্যাপের সাথে ভবিষ্যৎ ইন্টিগ্রেশন।  

**কীভাবে কাজ করে**:  
- স্টেকহোল্ডার ও প্রকল্প দল সব চাহিদা পর্যালোচনা করে।  
- প্রতিটি চাহিদাকে তার প্রভাব ও জরুরি ভিত্তিতে MoSCoW ক্যাটাগরিতে রাখা হয়।  
- “মাস্ট হ্যাভ” এবং “শুড হ্যাভ” চাহিদাগুলো আগে করা হয় যাতে সিস্টেম কার্যকর হয়।  

**কেন কার্যকর**:  
- এটি সহজ এবং বোঝা যায়।  
- গুরুত্বপূর্ণ ফিচার প্রাধান্য পায়, প্রকল্প ঠিক পথে থাকে।  
- স্টেকহোল্ডারদের প্রত্যাশা পরিচালনা করে, কী হবে বা হবে না তা পরিষ্কার করে।  

**ব্যাখ্যা**: MoSCoW মেথড চাহিদাগুলোকে গুরুত্ব অনুযায়ী ভাগ করে যাতে প্রকল্পের সময় ও বাজেটের মধ্যে সবচেয়ে জরুরি কাজ আগে হয়। এটি সহজ এবং কার্যকর কারণ এটি সিস্টেমের মূল ফিচারগুলো নিশ্চিত করে এবং সবাইকে একমত রাখে।

---
`Question Number: 3`
**iv) Describe the steps needed to construct the state chart diagrm. Show the relationship between an object state and state transition event.**


**English Answer**:
**Note**: A **figure is needed** to fully illustrate a state chart diagram. For the exam, you should draw a simple state chart diagram (e.g., for a bank account or traffic light) to show states and transitions. I’ll describe the steps and how to draw it below.

**Steps to Construct a State Chart Diagram**:
A state chart diagram shows how an object changes states based on events. The steps to create it are:
1. **Identify the Object**: Choose the object to model (e.g., a bank account).
2. **List States**: Identify all possible states the object can be in. For a bank account, states might be “Open,” “Active,” “Overdrawn,” and “Closed.”
3. **Define Events**: List events that cause the object to change states. For example, “Deposit,” “Withdraw,” or “Close Account.”
4. **Determine Transitions**: Map how each event moves the object from one state to another. For example, a “Withdraw” event might move the account from “Active” to “Overdrawn” if the balance goes negative.
5. **Add Actions**: Include any actions that happen during transitions (e.g., “Send overdraft notice” when moving to “Overdrawn”).
6. **Draw the Diagram**:
   - Use circles or rounded rectangles for each state (e.g., “Open,” “Active”).
   - Draw arrows between states to show transitions, labeling each arrow with the event (e.g., “Withdraw”).
   - Use a solid dot for the start state and a circled dot for the end state.
   - Add actions in brackets, like “[Send notice]” on transitions if needed.
7. **Validate**: Check that all states, events, and transitions make sense and cover all scenarios.
8. **Refine**: Simplify the diagram if it’s too complex, ensuring clarity.

**Relationship Between Object State and State Transition Event**:
- An **object state** is a specific condition or situation the object is in at a given time (e.g., “Active” for a bank account means it has a positive balance).
- A **state transition event** is an action or trigger that causes the object to move from one state to another (e.g., “Withdraw” event changes the state from “Active” to “Overdrawn”).
- The relationship is that the event acts as the cause, and the state change is the effect. Each transition is triggered by a specific event, and the object’s new state depends on the current state and the event.

**Drawing for Exam** (Example: Bank Account):
- Draw a solid dot (start).
- Draw an arrow to a circle labeled “Open.”
- From “Open,” draw an arrow labeled “Deposit” to a circle labeled “Active.”
- From “Active,” draw an arrow labeled “Withdraw” to a circle labeled “Overdrawn” with “[Send notice]” on the arrow.
- From “Active” and “Overdrawn,” draw arrows labeled “Close Account” to a circle labeled “Closed.”
- End with a circled dot from “Closed.”

**Bangla Translation and Explanation**:
**প্রশ্ন**: স্টেট চার্ট ডায়াগ্রাম তৈরির ধাপগুলো বর্ণনা করুন। অবজেক্ট স্টেট এবং স্টেট ট্রানজিশন ইভেন্টের মধ্যে সম্পর্ক দেখান।  
**উত্তর**:  
**দ্রষ্টব্য**: স্টেট চার্ট ডায়াগ্রাম পুরোপুরি বোঝাতে একটি **চিত্র প্রয়োজন**। পরীক্ষায় একটি সহজ স্টেট চার্ট ডায়াগ্রাম (যেমন, ব্যাংক অ্যাকাউন্ট বা ট্রাফিক লাইট) আঁকতে হবে যাতে স্টেট ও ট্রানজিশন দেখানো যায়। নিচে ধাপ ও আঁকার উপায় দেওয়া হলো।  

**স্টেট চার্ট ডায়াগ্রাম তৈরির ধাপ**:  
স্টেট চার্ট ডায়াগ্রাম দেখায় কীভাবে একটি অবজেক্ট ইভেন্টের ভিত্তিতে স্টেট বদলায়। ধাপগুলো হলো:  
1. **অবজেক্ট চিহ্নিত করা**: কোন অবজেক্ট মডেল করা হবে তা বেছে নিন (যেমন, ব্যাংক অ্যাকাউন্ট)।  
2. **স্টেট তালিকা করা**: অবজেক্টের সম্ভাব্য সব স্টেট চিহ্নিত করুন। যেমন, ব্যাংক অ্যাকাউন্টের জন্য “ওপেন,” “অ্যাকটিভ,” “ওভারড্রন,” এবং “ক্লোজড”।  
3. **ইভেন্ট নির্ধারণ**: স্টেট বদলানোর ইভেন্ট তালিকা করুন। যেমন, “ডিপোজিট,” “উইথড্র,” বা “ক্লোজ অ্যাকাউন্ট”।  
4. **ট্রানজিশন ম্যাপ করা**: প্রতিটি ইভেন্ট কীভাবে এক স্টেট থেকে অন্য স্টেটে নিয়ে যায় তা ঠিক করুন। যেমন, “উইথড্র” ইভেন্ট “অ্যাকটিভ” থেকে “ওভারড্রন” এ নিয়ে যায় যদি ব্যালেন্স নেগেটিভ হয়।  
5. **অ্যাকশন যোগ করা**: ট্রানজিশনের সময় যে অ্যাকশন হয় তা যোগ করুন (যেমন, “ওভারড্রন” এ যাওয়ার সময় “ওভারড্রাফট নোটিস পাঠানো”)।  
6. **ডায়াগ্রাম আঁকা**:  
   - প্রতিটি স্টেটের জন্য গোলাকার বা বাঁকা আয়তক্ষেত্র ব্যবহার করুন (যেমন, “ওপেন,” “অ্যাকটিভ”)।  
   - স্টেটের মধ্যে তীর দিয়ে ট্রানজিশন দেখান, তীরের উপর ইভেন্ট লিখুন (যেমন, “উইথড্র”)।  
   - শুরুর জন্য একটি কঠিন বিন্দু এবং শেষের জন্য একটি বৃত্তাকার বিন্দু ব্যবহার করুন।  
   - প্রয়োজনে ট্রানজিশনে অ্যাকশন যোগ করুন, যেমন “[নোটিস পাঠান]”।  
7. **যাচাই করা**: সব স্টেট, ইভেন্ট, এবং ট্রানজিশন ঠিক আছে কিনা চেক করুন এবং সব পরিস্থিতি কভার করা হয়েছে কিনা দেখুন।  
8. **পরিমার্জন করা**: ডায়াগ্রাম জটিল হলে সরল করুন যাতে পরিষ্কার থাকে।  

**অবজেক্ট স্টেট এবং স্টেট ট্রানজিশন ইভেন্টের সম্পর্ক**:  
- **অবজেক্ট স্টেট** হলো অবজেক্টের একটি নির্দিষ্ট অবস্থা বা পরিস্থিতি (যেমন, ব্যাংক অ্যাকাউন্টের “অ্যাকটিভ” মানে এতে পজিটিভ ব্যালেন্স আছে)।  
- **স্টেট ট্রানজিশন ইভেন্ট** হলো একটি ক্রিয়া বা ট্রিগার যা অবজেক্টকে এক স্টেট থেকে অন্য স্টেটে নিয়ে যায় (যেমন, “উইথড্র” ইভেন্ট “অ্যাকটিভ” থেকে “ওভারড্রন” এ নিয়ে যায়)।  
- সম্পর্ক হলো ইভেন্টটি কারণ হিসেবে কাজ করে, আর স্টেটের পরিবর্তন হলো ফলাফৈল। প্রতিটি ট্রানজিশন নির্দিষ্ট ইভেন্ট দ্বারা শুরু হয়, এবং নতুন স্টেট বর্তমান স্টেট ও ইভেন্টের উপর নির্ভর করে।  

**পরীক্ষায় আঁকা** (উদাহরণ: ব্যাংক অ্যাকাউন্ট):  
- একটি কঠিন বিন্দু দিয়ে শুরু করুন।  
- “ওপেন” লেবেলযুক্ত একটি বৃত্তে তীর দিন।  
- “ওপেন” থেকে “ডিপোজিট” লেবেলযুক্ত তীর দিয়ে “অ্যাকটিভ” বৃত্তে যান।  
- “অ্যাকটিভ” থেকে “উইথড্র” লেবেলযুক্ত তীর দিয়ে “ওভারড্রন” বৃত্তে যান, তীরে “[নোটিস পাঠান]” লিখুন।  
- “অ্যাকটিভ” এবং “ওভারড্রন” থেকে “ক্লোজ অ্যাকাউন্ট” লেবেলযুক্ত তীর দিয়ে “ক্লোজড” বৃত্তে যান।  
- “ক্লোজড” থেকে একটি বৃত্তাকার বিন্দুতে তীর দিয়ে শে�month।  

**ব্যাখ্যা**: স্টেট চার্ট ডায়াগ্রাম একটি অবজেক্টের বিভিন্ন অবস্থা এবং কীভাবে ইভেন্টের কারণে সেগুলো বদলায় তা দেখায়। এটি তৈরি করতে অবজেক্ট, স্টেট, ইভেন্ট, এবং ট্রানজিশন চিহ্নিত করে একটি চিত্র আঁকতে হয়। স্টেট হলো অবজেক্টের অবস্থা, আর ইভেন্ট হলো সেই অবস্থা বদলানোর কারণ। পরীক্ষায় একটি সহজ উদাহরণ (যেমন ব্যাংক অ্যাকাউন্ট) ব্যবহার করে ডায়াগ্রাম আঁকলে পয়েন্ট পাওয়া যাবে।


**v)  Define the visibility in object-oriented design. Explain the deffierent levels of visibility. Why are teh 3 kinds of object needed in object-oriented design.**

**English Answer**:
**Definition of Visibility**:
Visibility in object-oriented design (OOD) refers to how accessible an object’s attributes (data) or methods (functions) are to other objects or classes.

**Levels of Visibility**:
There are three main levels of visibility in OOD:
1. **Public**: Attributes or methods marked as public can be accessed by any class or object. For example, a public method like `getBalance()` in a bank account class can be called by any other class.
2. **Private**: Attributes or methods marked as private can only be accessed within the same class. For example, a private variable like `accountBalance` can only be used or changed by methods inside the bank account class, keeping it secure.
3. **Protected**: Attributes or methods marked as protected can be accessed within the same class and by subclasses (child classes) that inherit from it. For example, a protected method `calculateInterest()` can be used by the bank account class and its subclass, like a savings account class.

**Why Three Kinds of Objects Are Needed**:
In OOD, three types of objects are often used: **Entity Objects**, **Control Objects**, and **Boundary Objects**. They are needed for:
- **Entity Objects**: Represent the system’s data and business logic (e.g., a “Customer” object storing name and address). They are needed to manage and store information permanently.
- **Control Objects**: Manage the flow and logic of the system, coordinating interactions between objects (e.g., a “LoginController” object that handles user login). They are needed to ensure smooth operation and decision-making.
- **Boundary Objects**: Handle interactions between the system and external entities, like users or other systems (e.g., a “LoginScreen” object for user input). They are needed to provide a user interface or connect to external systems.

These three types work together to separate concerns (data, logic, and interface), making the system organized, maintainable, and scalable.

**Bangla Translation and Explanation**:
**প্রশ্ন**: অবজেক্ট-ওরিয়েন্টেড ডিজাইনে দৃশ্যমানতা (visibility) সংজ্ঞায়িত করুন। বিভিন্ন স্তরের দৃশ্যমানতা ব্যাখ্যা করুন। অবজেক্ট-ওরিয়েন্টেড ডিজাইনে তিন ধরনের অবজেক্ট কেন প্রয়োজন?  
**উত্তর**:  
**দৃশ্যমানতার সংজ্ঞা**:  
অবজেক্ট-ওরিয়েন্টেড ডিজাইনে দৃশ্যমানতা (visibility) হলো একটি অবজেক্টের অ্যাট্রিবিউট (ডেটা) বা মেথড (ফাংশন) অন্য অবজেক্ট বা ক্লাসের কাছে কতটা অ্যাক্সেসযোগ্য। এটি নিয়ন্ত্রণ করে ক্লাসের কোন অংশ অন্য ক্লাস ব্যবহার বা দেখতে পারে, যাতে ডেটা নিরাপদ থাকে এবং সঠিক মিথস্ক্রিয়া হয়।  

**দৃশ্যমানতার স্তর**:  
অবজেক্ট-ওরিয়েন্টেড ডিজাইনে তিনটি প্রধান দৃশ্যমানতার স্তর আছে:  
1. **পাবলিক (Public)**: পাবলিক হিসেবে চিহ্নিত অ্যাট্রিবিউট বা মেথড যেকোনো ক্লাস বা অবজেক্ট থেকে অ্যাক্সেস করা যায়। যেমন, ব্যাংক অ্যাকাউন্ট ক্লাসের `getBalance()` মেথড পাবলিক হলে যেকোনো ক্লাস এটি কলWELL করতে পারে।  
2. **প্রাইভেট (Private)**: প্রাইভেট হিসেবে চিহ্নিত অ্যাট্রিবিউট বা মেথড শুধু একই ক্লাসের মধ্যে অ্যাক্সেস করা যায়। যেমন, `accountBalance` নামে একটি প্রাইভেট ভ্যারিয়েবল শুধু ব্যাংক অ্যাকাউন্ট ক্লাসের মেথড ব্যবহার বা পরিবর্তন করতে পারে, এটি নিরাপদ রাখে।  
3. **প্রোটেক্টেড (Protected)**: প্রোটেক্টেড হিসেবে চিহ্নিত অ্যাট্রিবিউট বা মেথড একই ক্লাস এবং এটি থেকে উত্তরাধিকারসূত্রে প্রাপ্ত সাবক্লাস (চাইল্ড ক্লাস) অ্যাক্সেস করতে পারে। যেমন, `calculateInterest()` নামে একটি প্রোটেক্টেড মেথড ব্যাংক অ্যাকাউন্ট ক্লাস এবং এর সাবক্লাস, যেমন সেভিংস অ্যাকাউন্ট ক্লাস ব্যবহার করতে পারে।  

**তিন ধরনের অবজেক্ট কেন প্রয়োজন**:  
অবজেক্ট-ওরিয়েন্টেড ডিজাইনে তিন ধরনের অবজেক্ট ব্যবহৃত হয়: **এনটিটি অবজেক্ট**, **কন্ট্রোল অবজেক্ট**, এবং **বাউন্ডারি অবজেক্ট**। এগুলো প্রয়োজন কারণ:  
- **এনটিটি অবজেক্ট**: সিস্টেমের ডেটা এবং ব্যবসায়িক লজিক প্রতিনিধিত্ব করে (যেমন, “কাস্টমার” অবজেক্ট নাম ও ঠিকানা সংরক্ষণ করে)। এগুলো ডেটা স্থায়ীভাবে সংরক্ষণ ও ব্যবস্থাপনার জন্য দরকার।  
- **কন্ট্রোল অবজেক্ট**: সিস্টেমের প্রবাহ এবং লজিক ব্যবস্থাপনা করে, অবজেক্টগুলোর মধ্যে মিথস্ক্রিয়া সমন্বয় করে (যেমন, “লগইন কন্ট্রোলার” অবজেক্ট ব্যবহারকারীর লগইন পরিচালনা করে)। এগুলো সিস্টেমের সুষ্ঠু কার্যক্রম এবং সিদ্ধান্ত গ্রহণের জন্য দরকার।  
- **বাউন্ডারি অবজেক্ট**: সিস্টেম এবং বাহ্যিক সত্ত্বা, যেমন ব্যবহারকারী বা অন্য সিস্টেমের মধ্যে মিথস্ক্রিয়া পরিচালনা করে (যেমন, “লগইন স্ক্রিন” অবজেক্ট ব্যবহারকারীর ইনপুট নেয়)। এগুলো ইউজার ইন্টারফেস বা বাহ্যিক সিস্টেমের সাথে সংযোগের জন্য দরকার।  

এই তিন ধরনের অবজেক্ট ডেটা, লজিক, এবং ইন্টারফেস আলাদা করে সিস্টেমকে সংগঠিত, রক্ষণাবেক্ষণযোগ্য, এবং স্কেলযোগ্য করে।  

**ব্যাখ্যা**: দৃশ্যমানতা নিয়ন্ত্রণ করে ক্লাসের কোন অংশ অন্যরা ব্যবহার করতে পারবে। পাবলিক, প্রাইভেট, এবং প্রোটেক্টেড স্তর ডেটা নিরাপত্তা এবং সঠিক ব্যবহার নিশ্চিত করে। তিন ধরনের অবজেক্ট (এনটিটি, কন্ট্রোল, বাউন্ডারি) সিস্টেমের বিভিন্ন দিক (ডেটা, লজিক, ইন্টারফেস) পরিচালনা করে, যা সিস্টেমকে সুসংগঠিত এবং কার্যকর রাখে।

---
**vi) Show the key reason for object reusability. Which methods developer's use to achieve object reusability?**

**English Answer**:
**Key Reason for Object Reusability**:
The main reason for object reusability in object-oriented design is to **save time, effort, and cost** while improving system quality. Reusing objects (like classes or components) across projects or within the same system avoids rewriting code, reduces errors, and ensures consistency. For example, a reusable “User” class can be used in multiple apps, saving development time. The below method 

1. **Encapsulation**: This means keeping an object’s data (like variables) safe inside the object and only allowing access through special methods (like getters and setters). It’s like locking your phone with a password—only you control access. Example: A bank account hides its balance and lets you check it only through a `getBalance()` method.

2. **Inheritance**: This lets one class (child) take features (like methods or data) from another class (parent). It’s like a child inheriting traits from parents. Example: A “Car” class can inherit speed from a “Vehicle” class.

3. **Polymorphism**: This allows different classes to be treated as the same type, so they can use the same method in their own way. It’s like different animals making different sounds when you say “speak.” Example: A “Dog” and “Cat” class both have a `makeSound()` method, but Dog barks and Cat meows.

4. **Abstraction**: This hides complex details and shows only the simple, necessary parts. It’s like using a TV remote—you press buttons without knowing how it works inside. Example: A “Car” class lets you call `drive()` without knowing the engine’s details.

---

**vii) Describe the goal of constructing object robustness diagrams? What are the components of those diagrams?**

**English Answer**:
**Note**: A **figure is recommended** to illustrate a robustness diagram in the exam. You should draw a simple robustness diagram (e.g., for a login system) to show the components clearly. I’ll describe the components and how to draw it below.

**Goal of Constructing Object Robustness Diagrams**:
The goal of constructing object robustness diagrams is to **bridge the gap between analysis and design** by showing how use cases (requirements) translate into system behavior. They help validate that the system’s objects (entity, control, boundary) work together to fulfill use cases, ensuring the design is complete, correct, and robust. Specific goals include:
- **Validate Use Cases**: Ensure use cases are feasible and cover all scenarios.
- **Identify Objects**: Confirm the roles of entity, control, and boundary objects in the system.
- **Check Interactions**: Verify how objects communicate to achieve the use case’s functionality.
- **Improve Design**: Catch errors or missing elements early, making the system more reliable.

**Components of Robustness Diagrams**:
1. **Boundary Objects**: Represent interfaces between the system and external entities (e.g., users or other systems). Shown as a stick figure or rectangle with a vertical line on the left (e.g., “LoginScreen” for user input).
2. **Control Objects**: Manage the logic and coordination between objects. Shown as a circle with an arrow (e.g., “LoginController” to validate credentials).
3. **Entity Objects**: Represent data or business entities. Shown as a circle with a horizontal line at the bottom (e.g., “User” to store username and password).
4. **Actors**: External entities (e.g., users) interacting with the system. Shown as a stick figure (e.g., “User” who logs in).
5. **Links/Associations**: Arrows showing interactions between actors, boundary, control, and entity objects. Labeled with actions (e.g., “Enter credentials” from User to LoginScreen).



**Bangla Translation and Explanation**:
**প্রশ্ন**: অবজেক্ট রোবাস্টনেস ডায়াগ্রাম তৈরির লক্ষ্য বর্ণনা করুন। এই ডায়াগ্রামের উপাদানগুলো কী কী?  
**উত্তর**:  
**দ্রষ্টব্য**: রোবাস্টনেস ডায়াগ্রাম বোঝাতে পরীক্ষায় একটি **চিত্র আঁকা উচিত**। একটি সহজ রোবাস্টনেস ডায়াগ্রাম (যেমন, লগইন সিস্টেম) আঁকুন যাতে উপাদানগুলো পরিষ্কার হয়। নিচে উপাদান ও আঁকার উপায় দেওয়া হলো।  

**রোবাস্টনেস ডায়াগ্রাম তৈরির লক্ষ্য**:  
রোবাস্টনেস ডায়াগ্রাম তৈরির লক্ষ্য হলো **বিশ্লেষণ এবং ডিজাইনের মধ্যে সেতু তৈরি করা**। এটি দেখায় কীভাবে ইউজ-কেস (চাহিদা) সিস্টেমের আচরণে রূপান্তরিত হয়। এটি নিশ্চিত করে যে সিস্টেমের অবজেক্ট (এনটিটি, কন্ট্রোল, বাউন্ডারি) ইউজ-কেস পূরণের জন্য একসঙ্গে কাজ করে, যাতে ডিজাইন সম্পূর্ণ, সঠিক, এবং শক্তিশালী হয়। নির্দিষ্ট লক্ষ্য:  
- **ইউজ-কেস যাচাই**: ইউজ-কেস সম্ভব এবং সব পরিস্থিতি কভার করে তা নিশ্চিত করা।  
- **অবজেক্ট চিহ্নিত করা**: এনটিটি, কন্ট্রোল, এবং বাউন্ডারি অবজেক্টের ভূমিকা নিশ্চিত করা।  
- **মিথস্ক্রিয়া যাচাই**: অবজেক্টগুলো কীভাবে যোগাযোগ করে ইউজ-কেসের কার্যকারিতা অর্জন করে তা পরীক্ষা করা।  
- **ডিজাইন উন্নত করা**: আগে ভুল বা মিসিং উপাদান ধরে সিস্টেমকে নির্ভরযোগ্য করা।  

**রোবাস্টনেস ডায়াগ্রামের উপাদান**:  
1. **বাউন্ডারি অবজেক্ট**: সিস্টেম এবং বাহ্যিক সত্ত্বা (যেমন ব্যবহারকারী বা অন্য সিস্টেম) এর মধ্যে ইন্টারফেস প্রতিনিধিত্ব করে। স্টিক ফিগার বা বাম দিকে উল্লম্ব রেখাযুক্ত আয়তক্ষেত্র দিয়ে দেখানো হয় (যেমন, “লগইন স্ক্রিন” ব্যবহারকারীর ইনপুটের জন্য)।  
2. **কন্ট্রোল অবজেক্ট**: অবজেক্টগুলোর মধ্যে লজিক এবং সমন্বয় ব্যবস্থাপনা করে। তীরযুক্ত বৃত্ত দিয়ে দেখানো হয় (যেমন, “লগইন কন্ট্রোলার” শংসাপত্র যাচাই করে)।  
3. **এনটিটি অবজেক্ট**: ডেটা বা ব্যবসায়িক সত্ত্বা প্রতিনিধিত্ব করে। নিচে অনুভূমিক রেখাযুক্ত বৃত্ত দিয়ে দেখানো হয় (যেমন, “ইউজার” ইউজারনেম এবং পাসওয়ার্ড সংরক্ষণ করে)।  
4. **অ্যাক্টর**: সিস্টেমের সাথে মিথস্ক্রিয়া করা বাহ্যিক সত্ত্বা (যেমন ব্যবহারকারী)। স্টিক ফিগার দিয়ে দেখানো হয় (যেমন, “ইউজার” যিনি লগইন করেন)।  
5. **লিঙ্ক/সম্পর্ক**: অ্যাক্টর, বাউন্ডারি, কন্ট্রোল, এবং এনটিটি অবজেক্টের মধ্যে মিথস্ক্রিয়া দেখানো তীর। অ্যাকশন দিয়ে লেবেল করা হয় (যেমন, “শংসাপত্র প্রবেশ” থেকে ইউজার থেকে লগইন স্ক্রিন)।  

**পরীক্ষায় আঁকা** (উদাহরণ: লগইন সিস্টেম):  
- “ইউজার” লেবেলযুক্ত একটি স্টিক ফিগার আঁকুন (অ্যাক্টর)।  
- বাম দিকে উল্লম্ব রেখাযুক্ত আয়তক্ষেত্র আঁকুন, লেবেল “লগইন স্ক্রিন” (বাউন্ডারি অবজেক্ট)।  
- তীরযুক্ত বৃত্ত আঁকুন, লেবেল “লগইন কন্ট্রোলার” (কন্ট্রোল অবজেক্ট)।  
- নিচে অনুভূমিক রেখাযুক্ত বৃত্ত আঁকুন, লেবেল “ইউজার” (এনটিটি অবজেক্ট)।  
- তীর আঁকুন:  
  - “ইউজার” থেকে “লগইন স্ক্রিন” এ, লেবেল “শংসাপত্র প্রবেশ”।  
  - “লগইন স্ক্রিন” থেকে “লগইন কন্ট্রোলার” এ, লেবেল “শংসাপত্র যাচাই”।  
  - “লগইন কন্ট্রোলার” থেকে “ইউজার” (এনটিটি) এ, লেবেল “ইউজার ডেটা চেক”।  
  - “লগইন কন্ট্রোলার” থেকে “লগইন স্ক্রিন” এ, লেবেল “ফলাফল দেখান”।  

**ব্যাখ্যা**: রোবাস্টনেস ডায়াগ্রাম ইউজ-কেস থেকে ডিজাইনে যাওয়ার পথ দেখায় এবং নিশ্চিত করে যে সিস্টেমের অবজেক্ট সঠিকভাবে কাজ করে। এটি ভুল ধরতে এবং ডিজাইন উন্নত করতে সাহায্য করে। উপাদানগুলো (বাউন্ডারি, কন্ট্রোল, এনটিটি, অ্যাক্টর, লিঙ্ক) সিস্টেমের মিথস্ক্রিয়া পরিষ্কার করে। পরীক্ষায় একটি সহজ উদাহরণ (যেমন লগইন সিস্টেম) দিয়ে ডায়াগ্রাম আঁকলে পয়েন্ট পাওয়া যাবে।

---

These answers are written in simple English with enough detail to cover all aspects of the questions, making them ideal for exam purposes. The Bangla translations and explanations are also simple and clear for easy understanding. For question **vii)**, you should draw a robustness diagram in the exam, and I’ve provided a clear example (login system) with instructions to help you draw it. If you need more examples, further clarification, or help practicing any part (e.g., drawing the diagram), let me know!