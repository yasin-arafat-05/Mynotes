
---
---
---

<br>


### 2. Requirement analysis and specification (from SDLC)
- Try to understood the exact and complete requirement of the customer and document
them properly.
- Try to collect and analysis all data related to the project.
- In last, a large document will be written in the natural language which will describe what the system will do without describing it how, called SRS Software Requirement
Specification.
- Very critical phase because, a small error hear can result of sever problem in later stages

`customer exactly কি চাচ্ছে তা শুনে document করি । এরপর data collect and analysis করা । এমন একটা document বানানো natural language এ যাতে  বুঝতে পারে আমরা কি কি নিয়ে কাজ করবো । And lastly, this is very critical phase . `




---
---
---

<br>

### i) **Requirement Engineering**
Requirement engineering is the process of defining, documenting, and maintaining software requirements. It involves understanding what a system needs to do and ensuring that all stakeholders agree on the system's goals.

### ii) **Requirement Engineering Process**
1. **Feasibility Study**: This is an initial evaluation to determine if the project is viable technically, economically, and operationally.
2. **Requirement Gathering**: Collecting requirements from stakeholders, users, and other sources to define the system's needs.
3. **Software Requirement Specification (SRS)**: A detailed documentation of the system’s functional and non-functional requirements.
4. **Software Requirement Validation**: Ensures the documented requirements meet the stakeholders' needs and are feasible, complete, and consistent.


---
---
---

<br>

# `# Type of requirement:`

- User requirement
- System requirement

### User requirements:

User requirements are statements in a natural language plus diagrams of what services the System is expected to provide and the constraints under which it must operate . 

(User System এ কি কি  অপারেশন  চাচ্ছে কি হবে তা জানি  )

### System requirements:

System requirement set out the system functions, service and operational constarin in details. The system requirement document(Functional specification) should be precise. It should define exacty what is to be implemented.

(system কি কি  functions perform করবে এর কি কি  contrain থাকবে  বা পারবে না  সেই গুলো থাকবে )

---
---
---

<br>



# `# Functional Requirements:`


(`Funcitional Requrements: What দিয়ে প্রশ্ন করবো`)

These are features that describe **what the system should do**. They define the specific tasks or actions that the software must perform to meet users' needs.

Examples:
- **Search Function**: The system should let users search through stored information, like a list of bills or orders.
- **Email Reports**: Users should be able to send reports to management or other team members by email.
- **User Groups and Permissions**: The system should allow users to be grouped and given different levels of access. For example, some users can view all data, while others might only see part of it.
- **Business Rules**: The software must follow the company's rules or procedures. For example, if a company only approves orders over $500, the system should enforce that rule.
- **Backward Compatibility**: The software should still work with older versions of tools or systems the company has been using.




# `# Non-Functional Requirements:`

(`Non-Funcitional Requrements: How দিয়ে প্রশ্ন করবো`)

These are requirements about **how the system performs** rather than what it does. They focus on the system’s overall quality, speed, and security.

Examples:
- **Security**: The system should protect itself from unauthorized access, meaning only people with permission can use it.
- **Logging**: The system should record important activities or changes, so that there’s a record of what happened for future reference.
- **Storage**: The system should have enough space to store all the data it needs, like files or records.
- **Configuration**: Users should be able to easily change the system’s settings, like changing passwords or preferences.
- **Performance**: The system should work fast and be able to handle many tasks at the same time without slowing down.
- **Cost**: The software should be affordable and not cost too much to run or maintain.
- **Interoperability**: The software should work well with other systems or devices, like being able to share data with other software.
- **Flexibility**: The system should be easy to update or adjust when new features or changes are needed.
- **Disaster Recovery**: The system should have a plan to recover data and continue working if something goes wrong, like a power failure or system crash.
- **Accessibility**: The system should be easy to use for people with different needs, such as those with disabilities.


### Requirement Categories:
1. **Must Have**: Critical for the system to work. Without these, the software won’t function.
2. **Should Have**: Important features that improve the software but aren’t essential.
3. **Could Have**: Optional features that are nice to have but not necessary.
4. **Wish List**: Features that are not tied to the core objectives of the software but could be added later.

The focus during development should be on implementing the **Must Have** requirements, debating and discussing the **Should Have** features with stakeholders, while the **Could Have** and **Wish List** items can be added in future updates.

---
---
---

<br>


`(Requirement Grather করবো কীভাবে? Requirement Elicitation । )`

### iii) **Requirement Elicitation Process**
1. **Requirement Gathering**: Actively collecting information through various methods like interviews or surveys.
2. **Organizing Requirements**: Structuring and categorizing the collected information.
3. **Negotiation and Discussion**: Stakeholders discuss and resolve conflicting requirements.
4. **Documentation**: Writing down requirements in a formal document that serves as a reference for the entire project.


### iv) **Requirement Elicitation Techniques**
1. **Interviews**: One-on-one discussions to extract requirements directly from stakeholders.
2. **Surveys/Questionnaires**: Using structured questions to gather information from many stakeholders.
3. **Task Analysis**: Studying tasks users perform to understand the system's requirements.
4. **Domain Analysis**: Researching the environment and domain to identify standard practices and needs.
5. **Brainstorming**: Group discussions to generate ideas and clarify requirements.
6. **Prototyping**: Creating a preliminary model of the system to help stakeholders understand requirements better.
7. **Observation**: Watching users interact with the current system to identify requirements for improvement.



### v) **Software Requirement Characteristics**
- **Clear**: Requirements should be understandable by all stakeholders.
- **Correct**: They must accurately reflect the system’s needs.
- **Consistent**: No conflicting requirements.
- **Complete**: All system behaviors and interactions should be covered.
- **Verifiable**: The requirement should be testable to verify implementation.



### vi) **Software Requirements**
1. **Functional Requirements**: Describe what the system should do. Example: "The system must send a notification after a user registers."
2. **Non-Functional Requirements**: Define system attributes like security, reliability, performance, etc. Example: "The system must load in under 2 seconds."


### vii) **User Interface Requirements**
These specify how the system's interface should interact with users, including usability, accessibility, and design guidelines.


### viii) **Software System Analyst**
A system analyst bridges the gap between stakeholders and the development team. They ensure that requirements are correctly understood and implemented.



### ix) **Software Metrics and Measures**
1. **Size Metrics**: Measure the software’s size, typically using lines of code (LOC), function points, etc.
2. **Complexity Metrics**: Assess the complexity of the code or system design (e.g., Cyclomatic complexity).
3. **Quality Metrics**: Evaluate the software’s quality, including defect rates, customer satisfaction, etc.
4. **Process Metrics**: Measure aspects of the software development process such as time spent on different phases.
5. **Resources Metrics**: Track resource usage like time, money, and human effort during the development process.



